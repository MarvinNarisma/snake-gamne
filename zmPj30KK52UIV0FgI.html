<html><head><base href="." /><style>
body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
    background: 
        linear-gradient(45deg, rgba(255, 182, 193, 0.2) 25%, transparent 25%),
        linear-gradient(-45deg, rgba(255, 182, 193, 0.2) 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, rgba(255, 182, 193, 0.2) 75%),
        linear-gradient(-45deg, transparent 75%, rgba(255, 182, 193, 0.2) 75%);
    background-size: 40px 40px;
    background-position: 0 0, 0 20px, 20px -20px, -20px 0px;
    animation: candyBackground 10s linear infinite;
    position: relative;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
        radial-gradient(circle at 20% 20%, rgba(255, 107, 107, 0.4) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 182, 193, 0.4) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.2) 0%, transparent 70%);
    pointer-events: none;
}

@keyframes candyBackground {
    0% {
        background-position: 0 0, 0 20px, 20px -20px, -20px 0px;
    }
    100% {
        background-position: 40px 40px, 40px 60px, 60px 20px, 20px 40px;
    }
}

@keyframes candyStripe {
    0% { background-position: 0 0; }
    100% { background-position: 50px 50px; }
}

@keyframes textGlow {
    0% { text-shadow: 0 0 10px rgba(255, 107, 107, 0.4); }
    50% { text-shadow: 0 0 20px rgba(255, 107, 107, 0.8); }
}

@keyframes textHighlight {
    0% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
}

.button {
    padding: 15px 30px;
    font-size: 24px;
    font-weight: bold;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    width: 250px;
    background: repeating-linear-gradient(
        45deg,
        #ff6b6b,
        #ff6b6b 10px,
        #ff8787 10px,
        #ff8787 20px
    );
    color: white;
    text-shadow: 
        2px 2px 4px rgba(0, 0, 0, 0.5),
        0 0 20px rgba(255, 255, 255, 0.8),
        0 0 35px rgba(255, 107, 107, 0.6);
    animation: candyStripe 3s linear infinite, textGlow 2s infinite, textHighlight 2s ease-in-out infinite;
    position: relative;
    overflow: hidden;
    font-family: 'Comic Sans MS', cursive;
    letter-spacing: 2px;
    text-transform: uppercase;
}

.button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
        120deg,
        transparent,
        rgba(255, 255, 255, 0.3),
        transparent
    );
    animation: shine 2s infinite;
}

@keyframes shine {
    0% { left: -100%; }
    20% { left: 100%; }
    100% { left: 100%; }
}

.button:hover {
    transform: translateY(-4px) scale(1.05);
    box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
    background: repeating-linear-gradient(
        45deg,
        #ff8787,
        #ff8787 10px,
        #ffa4a4 10px,
        #ffa4a4 20px
    );
    text-shadow: 
        2px 2px 4px rgba(0, 0, 0, 0.5),
        0 0 20px rgba(255, 255, 255, 0.8),
        0 0 30px rgba(255, 107, 107, 0.6);
}

#gameCanvas {
    border: 3px solid #4CAF50;
    border-radius: 5px;
    box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
    display: none;
}

.score {
    color: #4CAF50;
    font-size: 24px;
    margin: 20px 0;
    text-shadow: 
        0 0 15px rgba(76, 175, 80, 0.7),
        0 0 25px rgba(76, 175, 80, 0.5);
    display: none;
    font-weight: bold;
    letter-spacing: 1px;
}

.game-over {
    display: none;
    position: absolute;
    font-family: 'Comic Sans MS', cursive;
    font-size: 36px;
    background: linear-gradient(45deg, #ff6b6b, #ff8787, #ffa4a4, #ff6b6b);
    background-size: 300% 300%;
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    animation: gradientFlow 3s ease infinite, popIn 0.5s ease-out;
    text-transform: uppercase;
    letter-spacing: 4px;
    text-shadow: 
        3px 3px 0px rgba(255, 107, 107, 0.6),
        6px 6px 0px rgba(255, 135, 135, 0.6),
        0 0 30px rgba(255, 107, 107, 0.8),
        0 0 60px rgba(255, 182, 193, 0.6);
    padding: 15px 30px;
    border-radius: 15px;
    background-color: rgba(0, 0, 0, 0.7);
    font-weight: bold;
}

.restart-button {
    padding: 10px 20px;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    cursor: pointer;
    background: repeating-linear-gradient(
        45deg,
        #4CAF50,
        #4CAF50 10px,
        #45a049 10px,
        #45a049 20px
    );
    color: white;
    text-shadow: 
        2px 2px 4px rgba(0, 0, 0, 0.5),
        0 0 15px rgba(255, 255, 255, 0.6);
    margin-top: 10px;
    animation: candyStripe 3s linear infinite;
    display: none;
    font-family: 'Comic Sans MS', cursive;
}

.restart-button:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
}

.return-home-button {
    padding: 10px 20px;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 15px;
    cursor: pointer;
    background: repeating-linear-gradient(
        45deg,
        #ff6b6b,
        #ff6b6b 10px,
        #ff8787 10px,
        #ff8787 20px
    );
    color: white;
    text-shadow: 
        2px 2px 4px rgba(0, 0, 0, 0.5),
        0 0 15px rgba(255, 255, 255, 0.6);
    margin-top: 10px;
    animation: candyStripe 3s linear infinite;
    display: none;
    font-family: 'Comic Sans MS', cursive;
}

.restart-button {
    margin-right: 10px;
}

/* Rest of the CSS... */
@keyframes popIn {
    0% { transform: scale(0); }
    70% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.game-over::before,
.game-over::after {
    content: 'üç¨';
    position: absolute;
    font-size: 28px;
    animation: candyBounce 1s ease-in-out infinite alternate;
}

.game-over::before {
    left: -40px;
}

.game-over::after {
    right: -40px;
}

@keyframes candyBounce {
    0% { transform: translateY(0) rotate(0deg); }
    100% { transform: translateY(-10px) rotate(10deg); }
}

.menu {
    display: flex;
    flex-direction: column;
    gap: 30px;
    align-items: center;
    background: linear-gradient(
        135deg,
        rgba(255, 182, 193, 0.4) 0%,
        rgba(255, 107, 107, 0.4) 100%
    );
    padding: 40px;
    border-radius: 20px;
    box-shadow: 
        0 0 30px rgba(255, 107, 107, 0.3),
        inset 0 0 20px rgba(255, 255, 255, 0.5);
    position: relative;
    border: 3px solid rgba(255, 182, 193, 0.6);
    background-image: 
        repeating-linear-gradient(
            45deg,
            transparent,
            transparent 10px,
            rgba(255, 255, 255, 0.1) 10px,
            rgba(255, 255, 255, 0.1) 20px
        );
    animation: candyGlow 3s infinite alternate;
}

.menu::before,
.menu::after {
    content: 'üç¨';
    position: absolute;
    font-size: 24px;
    animation: candySpin 3s ease-in-out infinite;
}

.menu::before {
    top: -15px;
    left: -15px;
}

.menu::after {
    bottom: -15px;
    right: -15px;
}

.menu::after {
    content: 'üç≠';
    bottom: -15px;
    right: -15px;
}

.menu::before {
    content: 'üç™';
    top: -15px;
    left: -15px;
}

@keyframes candySpin {
    0% { transform: rotate(0deg) scale(1); }
    50% { transform: rotate(180deg) scale(1.2); }
    100% { transform: rotate(360deg) scale(1); }
}

@keyframes candyGlow {
    0% { 
        box-shadow: 
            0 0 30px rgba(255, 107, 107, 0.3),
            inset 0 0 20px rgba(255, 255, 255, 0.5);
    }
    100% { 
        box-shadow: 
            0 0 40px rgba(255, 182, 193, 0.5),
            inset 0 0 30px rgba(255, 255, 255, 0.7);
    }
}

.menu::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.3) 0%, transparent 10%),
        radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.3) 0%, transparent 10%),
        radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.3) 0%, transparent 10%);
    animation: sparkle 2s infinite;
    pointer-events: none;
}

@keyframes sparkle {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 1; }
}

.campaign-level {
    color: #4CAF50;
    font-size: 20px;
    margin-bottom: 10px;
    display: none;
    font-weight: bold;
    text-shadow: 
        0 0 15px rgba(76, 175, 80, 0.7),
        0 0 25px rgba(76, 175, 80, 0.5);
    letter-spacing: 1px;
}

.logo {
    margin-bottom: 40px;
    text-align: center;
}

.logo-text {
    font-size: 48px;
    font-family: 'Comic Sans MS', cursive;
    background: linear-gradient(45deg, #ff6b6b, #ff8787, #ff6b6b);
    background-size: 300% 300%;
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    animation: gradientFlow 3s ease infinite;
    text-transform: uppercase;
    letter-spacing: 4px;
    text-shadow: 
        2px 2px 0px rgba(255, 107, 107, 0.6),
        4px 4px 0px rgba(255, 135, 135, 0.6),
        0 0 25px rgba(255, 107, 107, 0.8),
        0 0 50px rgba(255, 182, 193, 0.6);
    position: relative;
    display: inline-block;
}

.logo-text::before, .logo-text::after {
    content: 'üç¨';
    font-size: 36px;
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    animation: bounce 1s ease-in-out infinite alternate;
}

.logo-text::before {
    left: -50px;
}

.logo-text::after {
    right: -50px;
}

@keyframes gradientFlow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

@keyframes bounce {
    0% { transform: translateY(-50%) rotate(0deg); }
    100% { transform: translateY(-40%) rotate(10deg); }
}

.countdown-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 72px;
    font-family: 'Comic Sans MS', cursive;
    color: #ff6b6b;
    text-shadow: 
        3px 3px 0 #fff,
        -3px -3px 0 #fff,
        3px -3px 0 #fff,
        -3px 3px 0 #fff,
        0 0 30px rgba(255, 107, 107, 1),
        0 0 50px rgba(255, 107, 107, 0.8);
    display: none;
    animation: countdownPop 1s ease-out;
    font-weight: bold;
}

@keyframes countdownPop {
    0% { transform: translate(-50%, -50%) scale(0); }
    50% { transform: translate(-50%, -50%) scale(1.2); }
}

/* New CSS for candy message */
.candy-message {
    font-family: 'Comic Sans MS', cursive;
    font-size: 24px;
    margin-top: -20px;
    margin-bottom: 20px;
    background: linear-gradient(45deg, #ff6b6b, #ff8787, #ff6b6b);
    background-size: 300% 300%;
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    animation: gradientFlow 3s ease infinite, bounceText 2s ease-in-out infinite;
    text-shadow: 
        0 0 15px rgba(255, 107, 107, 0.6),
        0 0 30px rgba(255, 182, 193, 0.5);
    position: relative;
    font-weight: bold;
    letter-spacing: 2px;
}

@keyframes bounceText {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
}

.candy-message::before,
.candy-message::after {
    content: 'üç¨';
    position: absolute;
    font-size: 20px;
    top: 50%;
    transform: translateY(-50%);
    animation: candyFloat 2s ease-in-out infinite;
}

.candy-message::before {
    left: -30px;
    animation-delay: 0.5s;
}

.candy-message::after {
    right: -30px;
    animation-delay: 0s;
}

@keyframes candyFloat {
    0%, 100% { transform: translateY(-50%) rotate(0deg); }
    50% { transform: translateY(-70%) rotate(10deg); }
}

.falling-object {
    position: fixed;
    pointer-events: none;
    z-index: -1;
    animation: fall linear infinite;
    font-size: 24px;
    opacity: 0.5;
}

@keyframes fall {
    0% {
        transform: translateY(-20px) rotate(0deg);
    }
    100% {
        transform: translateY(100vh) rotate(360deg);
    }
}
</style></head><body>
<div class="logo">
    <h1 class="logo-text">Snake Game</h1>
</div>

<div class="candy-message">GET ALL THE CANDY!!!</div>

<div class="menu" id="mainMenu">
    <button class="button" onclick="startClassicMode()">Classic Mode</button>
    <button class="button" onclick="startCampaignMode()">Campaign Mode</button>
    <button class="button" onclick="quitGame()">Quit Game</button>
</div>

<div class="campaign-level" id="levelDisplay">Level: <span id="levelValue">1</span></div>
<div class="score">Score: <span id="scoreValue">0</span></div>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<div class="game-over" id="gameOver">Game Over!</div>
<div style="display: flex; gap: 10px; justify-content: center;">
    <button class="restart-button" id="restartButton" onclick="setupGame()">Restart Game</button>
    <button class="return-home-button" id="returnHomeButton" onclick="returnToHome()">Return Home</button>
</div>
<div class="countdown-overlay" id="countdown"></div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('scoreValue');
const gameOverElement = document.getElementById('gameOver');
const mainMenu = document.getElementById('mainMenu');
const levelDisplay = document.getElementById('levelDisplay');
const levelValue = document.getElementById('levelValue');

const gridSize = 20;
const tileCount = canvas.width / gridSize;

let snake = [{ x: 10, y: 10 }];
let food = { x: 15, y: 15 };
let dx = 0;
let dy = 0;
let score = 0;
let gameSpeed = 150;
let gameLoop;
let currentLevel = 1;
let isCampaignMode = false;

// Campaign mode objectives
const campaignLevels = [
    { target: 50, speed: 150 },
    { target: 100, speed: 140 },
    { target: 200, speed: 130 },
    { target: 300, speed: 120 },
    { target: 500, speed: 110 }
];

// Wall configurations
const wallConfigurations = [
    // Level 1 walls
    [
        {x: 5, y: 5}, {x: 5, y: 6}, {x: 5, y: 7},
    ],
    // Level 2 walls
    [
        {x: 10, y: 5}, {x: 10, y: 6}, {x: 10, y: 7},
        {x: 15, y: 10}, {x: 15, y: 11}, {x: 15, y: 12},
    ],
    // Level 3 walls
    [
        {x: 5, y: 5}, {x: 5, y: 6}, {x: 5, y: 7},
        {x: 15, y: 15}, {x: 15, y: 16}, {x: 15, y: 17},
        {x: 10, y: 10}, {x: 10, y: 11}, {x: 10, y: 12},
    ],
    // Level 4 walls
    [
        {x: 3, y: 3}, {x: 3, y: 4}, {x: 3, y: 5},
        {x: 17, y: 17}, {x: 17, y: 18}, {x: 17, y: 19},
        {x: 10, y: 10}, {x: 10, y: 11}, {x: 10, y: 12},
        {x: 15, y: 5}, {x: 15, y: 6}, {x: 15, y: 7},
    ],
    // Level 5 walls
    [
        {x: 5, y: 5}, {x: 5, y: 6}, {x: 5, y: 7},
        {x: 15, y: 15}, {x: 15, y: 16}, {x: 15, y: 17},
        {x: 10, y: 10}, {x: 10, y: 11}, {x: 10, y: 12},
        {x: 3, y: 15}, {x: 3, y: 16}, {x: 3, y: 17},
        {x: 17, y: 3}, {x: 17, y: 4}, {x: 17, y: 5},
    ]
];

let currentWalls = [];

// Add these functions right before the createFallingObjects function

function startClassicMode() {
    isCampaignMode = false;
    levelDisplay.style.display = 'none';
    currentLevel = 1;
    currentWalls = [];
    setupGame();
}

function startCampaignMode() {
    isCampaignMode = true;
    levelDisplay.style.display = 'block';
    currentLevel = 1;
    levelValue.textContent = currentLevel;
    currentWalls = [...wallConfigurations[currentLevel - 1]];
    setupGame();
}

// Modify the setupGame function to initialize walls
function setupGame() {
    mainMenu.style.display = 'none';
    canvas.style.display = 'block';
    document.querySelector('.score').style.display = 'block';
    gameOverElement.style.display = 'none';
    document.getElementById('restartButton').style.display = 'none';
    document.getElementById('returnHomeButton').style.display = 'none';
    
    snake = [{ x: 10, y: 10 }];
    score = 0;
    scoreElement.textContent = score;
    dx = 1;
    dy = 0;
    
    // Initialize walls for current level
    if (isCampaignMode && currentLevel <= wallConfigurations.length) {
        currentWalls = [...wallConfigurations[currentLevel - 1]];
    } else {
        currentWalls = [];
    }
    
    gameSpeed = isCampaignMode ? campaignLevels[currentLevel - 1].speed : 150;
    
    generateFood();
    
    // Start countdown
    const countdown = document.getElementById('countdown');
    countdown.style.display = 'block';
    let count = 3;
    
    const countdownInterval = setInterval(() => {
        countdown.textContent = count;
        countdown.style.animation = 'none';
        countdown.offsetHeight; // Trigger reflow
        countdown.style.animation = 'countdownPop 1s ease-out';
        count--;
        
        if (count < 0) {
            clearInterval(countdownInterval);
            countdown.style.display = 'none';
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(drawGame, gameSpeed);
        }
    }, 1000);
}

function quitGame() {
    window.close();
    window.location.href = "about:blank";
}

function returnToHome() {
    clearInterval(gameLoop);
    
    canvas.style.display = 'none';
    document.querySelector('.score').style.display = 'none';
    gameOverElement.style.display = 'none';
    document.getElementById('restartButton').style.display = 'none';
    document.getElementById('returnHomeButton').style.display = 'none';
    levelDisplay.style.display = 'none';
    
    mainMenu.style.display = 'flex';
    
    score = 0;
    currentLevel = 1;
    scoreElement.textContent = '0';
    levelValue.textContent = '1';
}

function checkLevelProgress() {
    if (isCampaignMode && currentLevel <= campaignLevels.length) {
        if (score >= campaignLevels[currentLevel - 1].target) {
            currentLevel++;
            levelValue.textContent = currentLevel;
            if (currentLevel <= campaignLevels.length) {
                gameSpeed = campaignLevels[currentLevel - 1].speed;
                clearInterval(gameLoop);
                gameLoop = setInterval(drawGame, gameSpeed);
            } else {
                gameOver("Campaign Completed!");
            }
        }
    }
}

function drawGame() {
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const head = { x: snake[0].x + dx, y: snake[0].y + dy };
    
    if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
        gameOver();
        return;
    }
    
    // Check wall collisions
    for (let wall of currentWalls) {
        if (head.x === wall.x && head.y === wall.y) {
            gameOver();
            return;
        }
    }
    
    for (let i = 0; i < snake.length; i++) {
        if (head.x === snake[i].x && head.y === snake[i].y) {
            gameOver();
            return;
        }
    }
    
    snake.unshift(head);
    
    if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreElement.textContent = score;
        generateFood();
        if (!isCampaignMode) {
            gameSpeed = Math.max(100, gameSpeed - 1);
            clearInterval(gameLoop);
            gameLoop = setInterval(drawGame, gameSpeed);
        }
        checkLevelProgress();
    } else {
        snake.pop();
    }
    
    // Draw walls
    currentWalls.forEach(wall => {
        // Create brick pattern
        ctx.fillStyle = '#8B4513'; // Brown color for walls
        ctx.fillRect(wall.x * gridSize, wall.y * gridSize, gridSize - 1, gridSize - 1);
        
        // Add brick texture
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        ctx.strokeRect(wall.x * gridSize, wall.y * gridSize, gridSize - 1, gridSize - 1);
        
        // Add highlight effect
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(wall.x * gridSize, wall.y * gridSize, gridSize - 1, gridSize / 2);
    });
    
    // Modified snake drawing to look like candy
    snake.forEach((segment, index) => {
        // Create candy stripe pattern for snake body
        const stripeWidth = gridSize / 4;
        const x = segment.x * gridSize;
        const y = segment.y * gridSize;
        
        // Create diagonal candy stripes
        for (let i = 0; i < gridSize; i += stripeWidth) {
            ctx.fillStyle = i % (stripeWidth * 2) === 0 ? '#ff6b6b' : '#ff8787';
            ctx.beginPath();
            ctx.moveTo(x + i, y);
            ctx.lineTo(x + i + stripeWidth, y);
            ctx.lineTo(x + i + stripeWidth, y + gridSize);
            ctx.lineTo(x + i, y + gridSize);
            ctx.fill();
        }
        
        // Add a glossy highlight effect
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.ellipse(
            x + gridSize / 2,
            y + gridSize / 4,
            gridSize / 3,
            gridSize / 6,
            0,
            0,
            Math.PI * 2
        );
        ctx.fill();

        // Draw border around segment
        ctx.strokeStyle = '#ff4444';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, gridSize - 2, gridSize - 2);
        
        // If this is the head segment, draw the eyes and tongue
        if (index === 0) {
            let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
            const eyeOffset = 4;
            const eyeSize = 3;
            const pupilSize = 2;
            
            if (dx === 1) {
                leftEyeX = segment.x * gridSize + gridSize - eyeOffset;
                leftEyeY = segment.y * gridSize + eyeOffset;
                rightEyeX = segment.x * gridSize + gridSize - eyeOffset;
                rightEyeY = segment.y * gridSize + gridSize - eyeOffset;
            } else if (dx === -1) {
                leftEyeX = segment.x * gridSize + eyeOffset;
                leftEyeY = segment.y * gridSize + eyeOffset;
                rightEyeX = segment.x * gridSize + eyeOffset;
                rightEyeY = segment.y * gridSize + gridSize - eyeOffset;
            } else if (dy === -1) {
                leftEyeX = segment.x * gridSize + eyeOffset;
                leftEyeY = segment.y * gridSize + eyeOffset;
                rightEyeX = segment.x * gridSize + gridSize - eyeOffset;
                rightEyeY = segment.y * gridSize + eyeOffset;
            } else {
                leftEyeX = segment.x * gridSize + eyeOffset;
                leftEyeY = segment.y * gridSize + gridSize - eyeOffset;
                rightEyeX = segment.x * gridSize + gridSize - eyeOffset;
                rightEyeY = segment.y * gridSize + gridSize - eyeOffset;
            }
            
            // Draw white eye backgrounds
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(leftEyeX, leftEyeY, eyeSize, 0, Math.PI * 2);
            ctx.arc(rightEyeX, rightEyeY, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw black pupils
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(leftEyeX, leftEyeY, pupilSize, 0, Math.PI * 2);
            ctx.arc(rightEyeX, rightEyeY, pupilSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw tongue
            ctx.fillStyle = '#ff0000';
            let tongueStartX, tongueStartY, tongueTipX, tongueTipY;
            const tongueLength = 8;
            const tongueWidth = 2;
            const tongueSpread = 4;
            
            if (dx === 1) {
                tongueStartX = segment.x * gridSize + gridSize;
                tongueStartY = segment.y * gridSize + gridSize / 2;
                tongueTipX = tongueStartX + tongueLength;
                tongueTipY = tongueStartY;
            } else if (dx === -1) {
                tongueStartX = segment.x * gridSize;
                tongueStartY = segment.y * gridSize + gridSize / 2;
                tongueTipX = tongueStartX - tongueLength;
                tongueTipY = tongueStartY;
            } else if (dy === -1) {
                tongueStartX = segment.x * gridSize + gridSize / 2;
                tongueStartY = segment.y * gridSize;
                tongueTipX = tongueStartX;
                tongueTipY = tongueStartY - tongueLength;
            } else {
                tongueStartX = segment.x * gridSize + gridSize / 2;
                tongueStartY = segment.y * gridSize + gridSize;
                tongueTipX = tongueStartX;
                tongueTipY = tongueStartY + tongueLength;
            }

            // Draw forked tongue
            ctx.beginPath();
            if (dx !== 0) {
                ctx.moveTo(tongueStartX, tongueStartY);
                ctx.lineTo(tongueTipX, tongueTipY - tongueSpread);
                ctx.moveTo(tongueStartX, tongueStartY);
                ctx.lineTo(tongueTipX, tongueTipY + tongueSpread);
            } else {
                ctx.moveTo(tongueStartX, tongueStartY);
                ctx.lineTo(tongueTipX - tongueSpread, tongueTipY);
                ctx.moveTo(tongueStartX, tongueStartY);
                ctx.lineTo(tongueTipX + tongueSpread, tongueTipY);
            }
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = tongueWidth;
            ctx.stroke();
        }
    });
    
    ctx.fillStyle = '#ff4444';
    ctx.beginPath();
    const centerX = food.x * gridSize + gridSize / 2;
    const centerY = food.y * gridSize + gridSize / 2;
    ctx.arc(centerX, centerY, gridSize / 2 - 2, 0, Math.PI * 2);
    ctx.fill();
}

function generateFood() {
    let validPosition = false;
    
    while (!validPosition) {
        food.x = Math.floor(Math.random() * tileCount);
        food.y = Math.floor(Math.random() * tileCount);
        
        validPosition = true;
        
        // Check if food spawned on snake
        for (let segment of snake) {
            if (segment.x === food.x && segment.y === food.y) {
                validPosition = false;
                break;
            }
        }
        
        // Check if food spawned on wall
        for (let wall of currentWalls) {
            if (wall.x === food.x && wall.y === food.y) {
                validPosition = false;
                break;
            }
        }
    }
}

function gameOver(message = "Game Over!") {
    clearInterval(gameLoop);
    gameOverElement.textContent = message;
    gameOverElement.style.display = 'block';
    document.getElementById('restartButton').style.display = 'inline-block';
    document.getElementById('returnHomeButton').style.display = 'inline-block';
    gameOverElement.style.animation = 'none';
    gameOverElement.offsetHeight; // Trigger reflow
    gameOverElement.style.animation = 'popIn 0.5s ease-out, gradientFlow 3s ease infinite';
    
    canvas.style.animation = 'shake 0.5s';
    setTimeout(() => {
        canvas.style.animation = '';
    }, 500);
}

document.addEventListener('keydown', (e) => {
    switch(e.key) {
        case 'ArrowUp':
            if (dy === 0) { dx = 0; dy = -1; }
            break;
        case 'ArrowDown':
            if (dy === 0) { dx = 0; dy = 1; }
            break;
        case 'ArrowLeft':
            if (dx === 0) { dx = -1; dy = 0; }
            break;
        case 'ArrowRight':
            if (dx === 0) { dx = 1; dy = 0; }
            break;
    }
});

function createFallingObjects() {
    const objects = ['üç¨', 'üç≠', 'üêç', 'üç™'];
    const container = document.body;
    
    setInterval(() => {
        const object = document.createElement('div');
        object.className = 'falling-object';
        object.textContent = objects[Math.floor(Math.random() * objects.length)];
        
        // Random horizontal position
        object.style.left = Math.random() * 100 + 'vw';
        
        // Random animation duration between 4 and 8 seconds
        const duration = 4 + Math.random() * 4;
        object.style.animationDuration = duration + 's';
        
        container.appendChild(object);
        
        // Remove the element after animation completes
        setTimeout(() => {
            object.remove();
        }, duration * 1000);
    }, 500); // Create new object every 500ms
}

createFallingObjects();
</script>
</body></html>